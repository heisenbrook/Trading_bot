// @version=6
// This script is designed to be used as a tool for technical analysis on TradingView.
// It combines Relative Strength Index (RSI), support/resistance levels, and advanced
// pattern recognition to generate a "safe" forecast signal.
//
// The "numerology" aspect is interpreted as the quantifiable identification
// of repeatable patterns in price action.

// ------------------- General Script Settings -------------------
indicator(title="Advanced Forecast Script", shorttitle="AFS", overlay=true, max_lines_count=500, max_labels_count=500)

// ------------------- User Inputs -------------------
// RSI Settings
rsiLen = input.int(14, title="RSI Period", minval=1)
rsiOverbought = input.int(70, title="RSI Overbought Level", minval=50)
rsiOversold = input.int(30, title="RSI Oversold Level", maxval=50)

// Support and Resistance Settings
srSource = input.source(close, title="Support/Resistance Source")
srLookback = input.int(20, title="S/R Lookback Period", minval=1)
srOffset = input.float(0.01, title="S/R Zone Offset (%)", minval=0.0)

// Fibonacci Settings
fibLookback = input.int(50, title="Fib Lookback Period", minval=10)

// Pattern Recognition and Forecasting Settings
patternLength = input.int(20, title="Pattern Length", minval=5, maxval=200)
lookbackBars = input.int(2000, title="Lookback Bars", minval=50, maxval=10000)
forecastBars = input.int(20, title="Forecast Bars", minval=1, maxval=200)
patternLookback = input.int(10, title="Pattern Lookback Period", minval=5)

// Volume Settings 
volumeLookback = input.int(20, title="Volume Average Period", minval=1)
volumeMultiplier = input.float(1.5, title="Volume Confirmation Multiplier", minval=1.0)
dailyVolumeSource = input.string("1D", title="Volume Timeframe", options=["1D", "1W", "1M"])

// ------------------- Indicator Calculations -------------------

// Relative Strength Index (RSI)
// The RSI is used to gauge the momentum of price changes and identify overbought/oversold conditions.
rsiValue = ta.rsi(close, rsiLen)

// Volume Calculation using request.security() for long-term data
longTermVolume = request.security(syminfo.tickerid, dailyVolumeSource, volume)
longTermAvgVolume = ta.sma(longTermVolume, volumeLookback)
isHighVolume = volume > (longTermAvgVolume * volumeMultiplier)

// ------------------- Support and Resistance (S/R) Logic -------------------
// Simple S/R detection based on highest and lowest values over a lookback period.
// This creates dynamic S/R zones that adapt to recent price action.
supportLevel = ta.lowest(srSource, srLookback)
resistanceLevel = ta.highest(srSource, srLookback)

// Define price zones around S/R levels
isNearSupport = (close <= supportLevel * (1 + srOffset))
isNearResistance = (close >= resistanceLevel * (1 - srOffset))

// ------------------- Fibonacci Retracement Logic -------------------
// Find the recent swing high and swing low based on the user-defined lookback period.
recentHigh = ta.highest(high, fibLookback)
recentLow = ta.lowest(low, fibLookback)

// Check if a valid price swing exists for retracement calculation.
isUptrend = recentHigh > recentLow
isDowntrend = recentLow < recentHigh

// Calculate key Fibonacci retracement levels for both uptrends and downtrends.
fib_382_uptrend = recentHigh - (recentHigh - recentLow) * 0.382
fib_500_uptrend = recentHigh - (recentHigh - recentLow) * 0.5
fib_618_uptrend = recentHigh - (recentHigh - recentLow) * 0.618

fib_382_downtrend = recentLow + (recentHigh - recentLow) * 0.382
fib_500_downtrend = recentLow + (recentHigh - recentLow) * 0.5
fib_618_downtrend = recentLow + (recentHigh - recentLow) * 0.618

// Determine if the current price is near a significant Fibonacci level.
// A tolerance of 0.5% is used for this check.
isNearFibUptrend = isUptrend and (math.abs(close - fib_382_uptrend) / fib_382_uptrend < 0.005 or math.abs(close - fib_500_uptrend) / fib_500_uptrend < 0.005 or math.abs(close - fib_618_uptrend) / fib_618_uptrend < 0.005)
isNearFibDowntrend = isDowntrend and (math.abs(close - fib_382_downtrend) / fib_382_downtrend < 0.005 or math.abs(close - fib_500_downtrend) / fib_500_downtrend < 0.005 or math.abs(close - fib_618_downtrend) / fib_618_downtrend < 0.005)

// ------------------- Candlestick Pattern Recognition -------------------
// We will check for a simple bullish engulfing and bearish engulfing pattern.
bullishEngulfing = close[1] < open[1] and close > open and close > open[1] and open < close[1]
bearishEngulfing = close[1] > open[1] and close < open and close < open[1] and open > close[1]

// A function to check if a specific pattern has occurred in the recent past.
checkPattern(pattern, lookback) =>
    result = false
    for i = 0 to lookback - 1
        if pattern[i]
            result := true
            break
    result

isBullishPattern = checkPattern(bullishEngulfing, patternLookback)
isBearishPattern = checkPattern(bearishEngulfing, patternLookback)

// ------------------- Combined Forecast Logic -------------------
// Combine RSI, S/R, pattern recognition, volume, and Fibonacci to generate a "forecast" signal.
bullishForecast = (rsiValue < rsiOversold) and isNearSupport and isBullishPattern and isHighVolume and isNearFibUptrend
bearishForecast = (rsiValue > rsiOverbought) and isNearResistance and isBearishPattern and isHighVolume and isNearFibDowntrend

// ------------------- Advanced Pattern Matching and Forecasting -------------------

// Function to calculate a normalized similarity score between two price arrays.
// A lower score indicates a better match.
normalizedSimilarity(arr1, arr2) =>
    base1 = array.get(arr1, 0)
    base2 = array.get(arr2, 0)
    score = 0.0
    for i = 0 to array.size(arr1) - 1
        v1 = (array.get(arr1, i) - base1) / base1
        v2 = (array.get(arr2, i) - base2) / base2
        score += math.abs(v1 - v2)
    score

// Collect the current price pattern.
var pattern = array.new_float()
if barstate.islast and bar_index >= patternLength
    array.clear(pattern)
    for i = 0 to patternLength - 1
        array.push(pattern, close[i])

// Find the best matching historical pattern.
var float bestScore = 1e10
var int bestIndex = na

// Determine a safe lookback limit to avoid index errors.
maxLookback = math.min(lookbackBars, bar_index - patternLength)

if barstate.islast and array.size(pattern) == patternLength
    for offset = patternLength to maxLookback
        if bar_index > offset + patternLength - 1
            window = array.new_float()
            for i = 0 to patternLength - 1
                array.push(window, close[offset + i])
            score = normalizedSimilarity(pattern, window)
            if score < bestScore
                bestScore := score
                bestIndex := bar_index - offset

// ------------------- Forecasting Line Drawing -------------------
if barstate.islast and not na(bestIndex)
    // Create a label at the location of the best match.
    label.new(x=bestIndex, y=close[bar_index - bestIndex], text="Best Match", style=label.style_label_down, color=color.red)

    // Draw the forecast line by projecting the historical pattern forward.
    basePast = close[bar_index - bestIndex]
    baseNow = close
    for i = 0 to forecastBars - 2
        // Ensure we don't go beyond the available history for the past pattern.
        if (bar_index - bestIndex + i + 1) < bar_index
            pastVal1 = close[bar_index - bestIndex + i]
            pastVal2 = close[bar_index - bestIndex + i + 1]

            // Calculate percentage change from the past pattern.
            norm1 = (pastVal1 - basePast) / basePast
            norm2 = (pastVal2 - basePast) / basePast

            // Scale the historical movement to the current price.
            y1 = baseNow * (1 + norm1)
            y2 = baseNow * (1 + norm2)

            line.new(x1=bar_index + i, y1=y1, x2=bar_index + i + 1, y2=y2, color=color.blue, width=2)


// ------------------- Plotting -------------------
// Plot RSI in a separate pane
plot(rsiValue, "RSI", color.new(color.blue, 0))
hline(rsiOverbought, "RSI Overbought", color.new(color.red, 0))
hline(rsiOversold, "RSI Oversold", color.new(color.green, 0))

// Plot Support and Resistance lines on the main chart.
plot(supportLevel, "Support", color.new(color.green, 0), style=plot.style_line, linewidth=2)
plot(resistanceLevel, "Resistance", color.new(color.red, 0), style=plot.style_line, linewidth=2)

// Plot Fibonacci levels
plot(isUptrend ? fib_382_uptrend : na, "Fib 38.2% (Up)", color.new(color.blue, 50), style=plot.style_line)
plot(isUptrend ? fib_500_uptrend : na, "Fib 50% (Up)", color.new(color.blue, 50), style=plot.style_line)
plot(isUptrend ? fib_618_uptrend : na, "Fib 61.8% (Up)", color.new(color.blue, 50), style=plot.style_line)

plot(isDowntrend ? fib_382_downtrend : na, "Fib 38.2% (Down)", color.new(color.orange, 50), style=plot.style_line)
plot(isDowntrend ? fib_500_downtrend : na, "Fib 50% (Down)", color.new(color.orange, 50), style=plot.style_line)
plot(isDowntrend ? fib_618_downtrend : na, "Fib 61.8% (Down)", color.new(color.orange, 50), style=plot.style_line)

// Plot the forecast signals on the chart
plotshape(bullishForecast, title="Bullish Forecast", location=location.belowbar, color=color.new(color.green, 0), style=shape.triangleup, size=size.small)
plotshape(bearishForecast, title="Bearish Forecast", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.small)

// Add a simple legend for the signals
bgcolor(bullishForecast ? color.new(color.green, 90) : na)
bgcolor(bearishForecast ? color.new(color.red, 90) : na)